---
title: "Proyecto 3 Riesgo de Mercado"
author: Hernández Fernández Maria Fernanda,Rosas Rios Leonardo Daniel,José Domingo
  Cortes Sandria, Pastrana Basilio Martha Lizeth
date: "2025-04-27"
output:
  pdf_document:
    toc: true
  html_document:
    toc: true
    number_sections: true
---

# Selección de Activos


# Valor en Riesgo NO paramétrico

```{r, message=FALSE, warning=FALSE}
library(quantmod) # para descargar datos de Yahoo Finance
library(goftest) # para pruebas de bondad de ajuste
library(corrplot) # para graficar matrices de correlación
library(fitdistrplus) # para ajustar distribuciones
library(dplyr) # para manipulación de datos
library(VGAM) # para ajustar distribuciones
library(tidyr) # para manipulación de datos
library(ggplot2) # para graficar
library(lubridate) # para manipulación de fechas
library(tidyr) # para manipulación de datos
library(knitr) # para crear tablas
library(stringr) # para manipulación de textos

```

**Emisoras**
```{r}
cartera <- c("AAPL","MSFT","NVDA","AMZN","META","GOOGL","AVGO","GOOG","TSLA","WMT","INTC","JPM","F","NKE","GS","NFLX","CVX","ADBE","BAC","C") 

getSymbols(cartera,src = "yahoo",from="2022-01-01", to="2025-03-01")
```
**Datos**

```{r}
d1 <- data.frame(P1=AAPL$AAPL.Close,P2=MSFT$MSFT.Close,P3=NVDA$NVDA.Close,P4=AMZN$AMZN.Close,P5=META$META.Close,P6=GOOGL$GOOGL.Close,P7=AVGO$AVGO.Close,P8=GOOG$GOOG.Close,P9=TSLA$TSLA.Close,P10=WMT$WMT.Close,P11=INTC$INTC.Close,P12=JPM$JPM.Close,P13=F$F.Close,P14=NKE$NKE.Close,P15=GS$GS.Close,P16=NFLX$NFLX.Close,P17=CVX$CVX.Close,P18=ADBE$ADBE.Close,P19=BAC$BAC.Close,P20=C$C.Close)


```

```{r, message=FALSE, warning=FALSE}

d1$Fecha <- index(AAPL)  

# Convertir d1 a formato data.frame si no lo es (en caso de provenir de un objeto xts):
d1_df <- data.frame(Fecha = d1$Fecha, coredata(d1)[ , !(names(d1) %in% "Fecha")])

# Convertir a formato largo: una fila por cada fecha y ticker
d1_larga <- pivot_longer(d1_df, 
                         cols = -Fecha, 
                         names_to = "Ticker", 
                         values_to = "Close")

# Graficar la serie de tiempo de precios de cierre
ggplot(d1_larga, aes(x = Fecha, y = Close, color = Ticker)) +
  geom_line(size = 0.8) +
  labs(title = "Serie de Tiempo de Precios de Cierre",
       x = "Fecha", 
       y = "Precio de Cierre (USD)") +
  theme_minimal() +
  theme(legend.position = "bottom")
```

```{r}

colnames(d1) <- c("P1","P2","P3","P4","P5","P6","P7","P8","P9","P10","P11","P12","P13","P14","P15","P16","P17","P18","P19","P20")

n <- length(d1$P1) #número de días 
m <- length(d1[1,])  #número de emisoras
nc <- c(0.95,0.97,0.99) #niveles de confianza
numsim <- c(5000,10000,20000) #número de simulaciones
dias <- c(1, 7, 15, 30, 60, 90, 180)  #horizontes de tiempo

```


```{r}
# Separar solo las columnas de precios (sin la columna Fecha)
d1_precios <- d1[ , 1:20]  # si las primeras 20 columnas son los precios

n <- nrow(d1_precios)
m <- ncol(d1_precios)

Rend <- matrix(NA, nrow = n - 1, ncol = m)
colnames(Rend) <- paste0("P", 1:m)

for(k in 1:m){
  for(j in 1:(n-1)){
    Rend[j, k] <- d1_precios[j+1, k] / d1_precios[j, k] - 1
  }
}

```




**Grafica de los rendimientos**

```{r}
# Crear un data frame con las fechas adecuadas
fechas <- index(AAPL)[-1]  # remover la primera para alinear con los rendimientos
Rend_df <- as.data.frame(Rend)
Rend_df$Fecha <- fechas

# Convertir a formato largo
Rend_long <- pivot_longer(Rend_df, cols = starts_with("P"),
                          names_to = "Emisora", values_to = "Rendimiento")


```


**Función de perdidas y ganancias**
```{r}
PL <- matrix(data=0,nrow = n-1,ncol = m+1)
colnames(PL) <- c(paste0("P", 1:m), "PT")

for(k in 1:m){
  for(j in 1:n-1){
    PL[j,k] <- d1[n,k]-d1[n,k]*(1+Rend[j,k])  #pérdida/ganancia simulada
    PL[j,(m+1)] <- sum(PL[j,1:m])           #portafolio total
  }
}

```

## VaR por Simulación Histórica 

**VaR individual y de portafolio**

```{r}
PL <- cbind(PL, PT = rowSums(PL, na.rm = TRUE))
m <- ncol(PL)  # esto ya incluye la columna PT al final
VaRInd <- matrix(nrow = m, ncol = length(nc))
colnames(VaRInd) <- c("VaR_95%","VaR_97%","VaR_99%")
rownames(VaRInd) <- colnames(PL)[1:m]

for(k in 1:m){
  for(j in seq_along(nc)){
    VaRInd[k, j] <- quantile(PL[,k], nc[j], na.rm = TRUE)[1]
  }
}

#VaR ajustado a diferentes horizontes de tiempo

VaRIndD <- list()  #lista de emisoras

for (k in 1:m) {
  MVaRD <- matrix(nrow = length(dias), ncol = length(nc))
  for (i in seq_along(dias)) {
    for (j in seq_along(nc)) {
      MVaRD[i, j] <- VaRInd[k, j] * sqrt(dias[i])
    }
  }
  colnames(MVaRD) <- paste0("VaR_", nc * 100, "%")
  rownames(MVaRD) <- paste0(dias, "días")
  VaRIndD[[ colnames(PL)[k] ]] <- MVaRD
}
# ES: Expected Shortfall
VaR_ES <- function(PL, niveles_confianza = c(0.95, 0.97, 0.99)) {
  m <- ncol(PL)  # número de emisoras
  VaR <- matrix(NA, nrow = m, ncol = length(niveles_confianza))
  ES  <- matrix(NA, nrow = m, ncol = length(niveles_confianza))
  
  colnames(VaR) <- paste0("VaR_", niveles_confianza * 100, "%")
  colnames(ES)  <- paste0("ES_", niveles_confianza * 100, "%")
  rownames(VaR) <- rownames(ES) <- colnames(PL)
  
  for (k in 1:m) {
    for (j in seq_along(niveles_confianza)) {
      var_kj <- quantile(PL[, k], niveles_confianza[j], na.rm = TRUE)
      VaR[k, j] <- var_kj
      ES[k, j] <- mean(PL[, k][PL[, k] > var_kj], na.rm = TRUE)
    }
  }
  
  return(list(VaR = VaR, ES = ES))
}

ES.SH <- VaR_ES(PL) # Calcular VaR y ES
# ES ajustado a diferentes horizontes de tiempo
ESIndD <- list()

for (k in 1:m) {
  MESD <- matrix(nrow = length(dias), ncol = length(nc))
  for (i in seq_along(dias)) {
    for (j in seq_along(nc)) {
      MESD[i, j] <- ES.SH$ES[k, j] * sqrt(dias[i])
    }
  }
  colnames(MESD) <- paste0("ES_", nc * 100, "%")
  rownames(MESD) <- paste0(dias, "días")
  ESIndD[[colnames(PL)[k]]] <- MESD
}


```
#### tabla 

```{r, message=FALSE, warning=FALSE}

tabla_individual <- do.call(rbind, lapply(names(VaRIndD), function(nombre) {
  df <- as.data.frame(VaRIndD[[nombre]])
  df$Horizonte <- rownames(df)
  df$Emisora <- nombre
  df$ES_95 <- ESIndD[[nombre]][, 1]
  df$ES_97 <- ESIndD[[nombre]][, 2]
  df$ES_99 <- ESIndD[[nombre]][, 3]

  df
}))

# Reordenar columnas para claridad
tabla_individual <- tabla_individual[, c("Emisora", "Horizonte", 
                                         "VaR_95%", "VaR_97%", "VaR_99%", 
                                         "ES_95", "ES_97", "ES_99")]

## Ordenar por el número que sigue a la 'P'
tabla_individual <- tabla_individual[order(as.numeric(gsub("P", "", tabla_individual$Emisora)),
                                           as.numeric(tabla_individual$Horizonte)), ]


# Mostrar como tabla en RMarkdown
tabla_individual

```















## VaR Simulación Monte Carlo Normal 
```{r, warning=FALSE}
# Extraer fechas y datos numéricos
fechas <- d1[[which(sapply(d1, inherits, "Date"))]]
d1 <- d1[, sapply(d1, is.numeric)]

# Estimar parámetros mu y sigma para cada emisora
y <- function(x) {
  mod <- fitdist(x[!is.na(x)], "norm", method = "mle")
  return(mod$estimate)
}
p <- apply(Rend, 2, y)
muv <- p[1, ]
sigmav <- p[2, ]

emisoras <- colnames(d1)
precio_actuales <- as.numeric(d1[n, ])
resultados <- data.frame()
numsim_vec <- c(5000, 10000, 20000)

set.seed(123)

for (s in numsim_vec) {
  # Emisoras individuales
  for (j in seq_along(emisoras)) {
    mu <- muv[j]
    sigma <- sigmav[j]
    precio_actual <- precio_actuales[j]
    
    for (h in dias) {
      sim_rend <- matrix(rnorm(s * h, mu, sigma), ncol = h)
      sim_acum <- rowSums(sim_rend)
      sim_precios <- precio_actual * (1 + sim_acum)
      sim_perdidas <- precio_actual - sim_precios
      
      for (conf in nc) {
        var <- quantile(sim_perdidas, probs = conf, na.rm = TRUE)
        es <- mean(sim_perdidas[sim_perdidas > var], na.rm = TRUE)
        
        resultados <- rbind(resultados, data.frame(
          NumSim = s,
          Emisora = emisoras[j],
          Horizonte = h,
          Confianza = conf,
          VaR = var,
          ES = es
        ))
      }
    }
  }

  # Portafolio
  mu_port <- mean(rowMeans(Rend, na.rm = TRUE))
  sigma_port <- sd(rowMeans(Rend, na.rm = TRUE))
  precio_port <- sum(precio_actuales)
  
  for (h in dias) {
    sim_rend <- matrix(rnorm(s * h, mu_port, sigma_port), ncol = h)
    sim_acum <- rowSums(sim_rend)
    sim_precios <- precio_port * (1 + sim_acum)
    sim_perdidas <- precio_port - sim_precios
    
    for (conf in nc) {
      var <- quantile(sim_perdidas, probs = conf, na.rm = TRUE)
      es <- mean(sim_perdidas[sim_perdidas > var], na.rm = TRUE)
      
      resultados <- rbind(resultados, data.frame(
        NumSim = s,
        Emisora = "PT",
        Horizonte = h,
        Confianza = conf,
        VaR = var,
        ES = es
      ))
    }
  }
}


```

### Tabla
```{r, warning=FALSE, message=FALSE}
# Crear tabla
tabla_final <- resultados %>%
  pivot_wider(
    names_from = Confianza,
    values_from = c(VaR, ES),
    names_glue = "{.value}{round(100 * Confianza)}"
  ) %>%
  mutate(Emisora_num = ifelse(Emisora == "PT", Inf, as.numeric(gsub("P", "", Emisora)))) %>%
  arrange(NumSim, Emisora_num, Horizonte) %>%
  select(NumSim, Emisora, Horizonte, starts_with("VaR"), starts_with("ES"))

tabla_final

```


## VaR individual por Simulación Monte Carlo Laplace



```{r, warning=FALSE, message=FALSE}

# === 1. Estimar parámetros Laplace por emisora ===
ajustar_laplace <- function(x) {
  datos <- x[!is.na(x)]
  mod <- vglm(datos ~ 1, laplace, trace = FALSE)
  coef(mod)
}
param_laplace <- apply(Rend, 2, ajustar_laplace)
mu_lap <- param_laplace[1, ]
b_lap <- param_laplace[2, ]

emisoras <- colnames(Rend)
precio_actuales <- as.numeric(d1[n, ])
resultados <- data.frame()
numsim_vec <- c(5000, 10000, 20000)

set.seed(123)

# === 2. Simulación por emisora ===
for (s in numsim_vec) {
  for (j in seq_along(emisoras)) {
    mu <- mu_lap[j]
    b <- max(b_lap[j], 1e-6)
    precio_actual <- precio_actuales[j]
    
    for (h in dias) {
      sim_rend <- matrix(rlaplace(s * h, location = mu, scale = b), ncol = h)
      sim_acum <- rowSums(sim_rend)
      sim_precios <- precio_actual * (1 + sim_acum)
      sim_perdidas <- precio_actual - sim_precios  # 👈 pérdida = precio actual - futuro

      for (conf in nc) {
        alpha <- 1 - conf
        var <- quantile(sim_perdidas, probs = alpha, na.rm = TRUE)
        es <- mean(sim_perdidas[sim_perdidas >= var], na.rm = TRUE)  # 👈 pérdidas peores que VaR
        
        resultados <- rbind(resultados, data.frame(
          NumSim = s,
          Emisora = emisoras[j],
          Horizonte = h,
          Confianza = conf,
          VaR = var,
          ES = es
        ))
      }
    }
  }
  
  # === 3. Simulación del Portafolio ===
  mu_pt <- mean(rowMeans(Rend, na.rm = TRUE))
  sigma_pt <- sd(rowMeans(Rend, na.rm = TRUE))
  mu_pt_lap <- mu_pt
  b_pt_lap <- max(sigma_pt / sqrt(2), 1e-6)
  precio_pt <- sum(precio_actuales)
  
  for (h in dias) {
    sim_rend <- matrix(rlaplace(s * h, location = mu_pt_lap, scale = b_pt_lap), ncol = h)
    sim_acum <- rowSums(sim_rend)
    sim_precios <- precio_pt * (1 + sim_acum)
    sim_perdidas <- precio_pt - sim_precios  # 👈 pérdida del portafolio
    
    for (conf in nc) {
      alpha <- 1 - conf
      var <- quantile(sim_perdidas, probs = alpha, na.rm = TRUE)
      es <- mean(sim_perdidas[sim_perdidas >= var], na.rm = TRUE)
      
      resultados <- rbind(resultados, data.frame(
        NumSim = s,
        Emisora = "PT",
        Horizonte = h,
        Confianza = conf,
        VaR = var,
        ES = es
      ))
    }
  }
}


```



### Tabla 
```{r, warning=FALSE, message=FALSE}

# === 4. tabla de resultados ===
tabla_final <- resultados %>%
  pivot_wider(
    names_from = Confianza,
    values_from = c(VaR, ES),
    names_glue = "{.value}{round(100 * Confianza)}"
  ) %>%
  mutate(Emisora_num = ifelse(Emisora == "PT", Inf, as.numeric(gsub("P", "", Emisora)))) %>%
  arrange(NumSim, Emisora_num, Horizonte) %>%
  select(NumSim, Emisora, Horizonte, starts_with("VaR"), starts_with("ES"))

# Mostrar tabla
tabla_final
```





































```{r, warning=FALSE, message=FALSE}

#Ajustamos distribución Laplace a los rendimientos

# Función para estimar parámetros Laplace
ajustar_laplace <- function(x) {
  datos <- x[!is.na(x)]
  mod <- vglm(datos ~ 1, laplace, trace = FALSE)
  coef <- Coef(mod)
  return(coef)
}

# Estimar parámetros Laplace para cada emisora
param_laplace <- apply(Rend, 2, ajustar_laplace)
mu_lap <- param_laplace[1, ]
b_lap <- param_laplace[2, ]
```

```{r}
#Pérdidas
set.seed(123)

VaR_Laplace_conv <- list()

for (p in 1:m) {
  mu <- mu_lap[p]
  b <- b_lap[p]
  pf <- d1[n, p]  # último precio
  
  VaR_sims <- list()
  
  for (nsim in numsim) {
    pl_hist <- numeric(nsim)
    VaRm <- matrix(NA, nrow = nsim, ncol = length(nc))
    colnames(VaRm) <- paste0("VaR_", nc * 100, "%")
    
    for (j in 1:nsim) {
      rend_sim <- rlaplace(1, location = mu, scale = b)
      reval <- pf * (1 + rend_sim)
      pl <- pf - reval
      pl_hist[j] <- pl
      
      for (i in seq_along(nc)) {
        VaRm[j, i] <- quantile(pl_hist[1:j], probs = nc[i], na.rm = TRUE)
      }
    }
    
    VaR_sims[[as.character(nsim)]] <- VaRm
  }
  
  VaR_Laplace_conv[[colnames(Rend)[p]]] <- VaR_sims
}
```

```{r}
#Calculamos promedios de VaR por emisora y simulación
resVaR_Laplace <- data.frame()

for (emisora in names(VaR_Laplace_conv)) {
  for (nsim in names(VaR_Laplace_conv[[emisora]])) {
    matrizVaR <- VaR_Laplace_conv[[emisora]][[nsim]]
    promedios <- colMeans(matrizVaR, na.rm = TRUE)
    
    temp <- data.frame(
      Emisora = emisora,
      Simulaciones = as.integer(nsim),
      Nivel_Confianza = names(promedios),
      VaR_Promedio = as.numeric(promedios)
    )
    
    resVaR_Laplace <- bind_rows(resVaR_Laplace, temp)
  }
}


knitr::kable(resVaR_Laplace,caption = "Promedio de VaR por Emisora y Nivel de Confianza",digits = 4,align = "c")

```

**Expected Shortfall SM-Laplace**
```{r}
ES.MCL <- VaR_ES(VaRm)
```

```{r}
knitr::kable(
  ES.MCL,
  caption = "Expected Shortfall (ES) por Simulación Monte Carlo Laplace",
  digits = 4,
  align = "c")
```



##Simulación Bootstrapping


```{r}
emisoras <- colnames(Rend)
precio_actuales <- d1[n, ]  # precios actuales
resultados <- data.frame()

set.seed(123)

# Simulación por emisora
for (s in numsim_vec) {
  for (j in seq_along(emisoras)) {
    y <- Rend[, j]
    precio <- precio_actuales[j]
    
    for (h in dias) {
      sim_rend <- matrix(sample(y, s * h, replace = TRUE), ncol = h)
      sim_acum <- rowSums(sim_rend)
      sim_precios <- precio * (1 + sim_acum)
      sim_perdidas <- precio - sim_precios
      
      vars <- sapply(nc, function(conf) quantile(sim_perdidas, probs = conf, na.rm = TRUE))
      ess <- sapply(vars, function(v) {
      perdidas_extremas <- sim_perdidas[sim_perdidas > v]
      if (length(perdidas_extremas) == 0) {
    return(NA_real_)
    } else {
     return(mean(perdidas_extremas, na.rm = TRUE))
  }
})


      
      resultados <- rbind(resultados, data.frame(
        NumSim = s,
        Emisora = emisoras[j],
        Horizonte = h,
        VaR95 = vars[1], VaR97 = vars[2], VaR99 = vars[3],
        ES95 = ess[1], ES97 = ess[2], ES99 = ess[3]
      ))
    }
  }

  # Simulación para el portafolio completo
  for (h in dias) {
  sim_perdidas_pt <- numeric(s)
  
  for (i in 1:s) {
    pl_total <- 0
    for (j in seq_along(emisoras)) {
      y <- as.numeric(Rend[, j])
      y <- y[!is.na(y)]  # quitar NAs
      
      if (length(y) == 0 || is.na(precio_actuales[j])) {
        next  # saltar si no hay datos válidos
      }
      
      r <- sample(y, h, replace = TRUE)
      rend_acum <- sum(r, na.rm = TRUE)
      
      precio <- precio_actuales[j]
      reval <- precio * (1 + rend_acum)
      pl <- precio - reval
      pl_total <- pl_total + pl
    }
    sim_perdidas_pt[i] <- pl_total
  }

  # Validar que sim_perdidas_pt tenga valores numéricos válidos
  sim_perdidas_pt <- sim_perdidas_pt[!is.na(sim_perdidas_pt)]

  if (length(sim_perdidas_pt) > 0) {
    vars <- sapply(nc, function(conf) quantile(sim_perdidas_pt, probs = conf, na.rm = TRUE))
    ess <- sapply(vars, function(v) {
      losses <- sim_perdidas_pt[sim_perdidas_pt > v]
      if (length(losses) > 0) mean(losses) else NA
    })
    
    resultados <- rbind(resultados, data.frame(
      NumSim = s,
      Emisora = "PT",
      Horizonte = h,
      VaR95 = vars[1], VaR97 = vars[2], VaR99 = vars[3],
      ES95 = ess[1], ES97 = ess[2], ES99 = ess[3]
    ))
  }
  }
}

# Mostrar tabla
knitr::kable(
  resultados,
  caption = "Simulación Bootstrap Multivariada - VaR y ES por Emisora y Portafolio",
  digits = 4,
  align = "c"
)
```




































**Simulación Bootstrapping multivariada del portafolio**
```{r}

# Simulación bootstrap multivariada
RendSim <- matrix(NA, nrow = n, ncol = m)
Reval <- matrix(NA, nrow = n, ncol = m)
PL <- matrix(NA, nrow = n, ncol = m)
colnames(RendSim) <- colnames(Reval) <- colnames(PL) <- colnames(d1)

# Para cada emisora, simula rendimientos y calcula P&L
for (k in 1:m) {
  y <- Rend[, k]  # rendimientos históricos de la emisora k
  PA <- d1[n, k]  # precio actual

  for (j in 1:n) {
    RendSim[j, k] <- sample(y, 1, replace = TRUE)
    Reval[j, k] <- PA * (1 + RendSim[j, k])
    PL[j, k] <- PA - Reval[j, k]
  }
}

# Pérdida total del portafolio
PL_Total <- rowSums(PL, na.rm = TRUE)

#Calcular VaR por Simulación Bootstrap 
VaR_Bootstrap <- quantile(PL_Total, probs = c(0.90, 0.95, 0.99), na.rm = TRUE)

print(VaR_Bootstrap)

```


**Simulación bootstrap para VaR individual**

```{r}
#Individual
# Suposiciones: ya tienes Rend calculado como una matriz de rendimientos (n-1 x m)
# y d1 como la matriz de precios originales (n x m)
VaRconvergencia <- list()  # para almacenar los resultados

for (s in numsim) {

  VaRLim <- matrix(NA, nrow = s, ncol = m)  # almacenar pérdidas por emisora
  colnames(VaRLim) <- colnames(d1)

  for (j in 1:s) {
    
    PL_sim <- numeric(ncol(d1))  # Pérdida simulada por emisora
    for (k in 1:ncol(d1)) {
      y <- Rend[, k]  # rendimientos históricos de emisora k
      r <- sample(y, 1, replace = TRUE)  # rendimiento simulado
      PA <- d1[n, k]  # precio actual
      PL_sim[k] <- PA - (PA * (1 + r))  # pérdida simulada
    }
    
    VaRLim[j, ] <- PL_sim  # guardar pérdidas individuales

  }
}
  
VaR_individual <- apply(VaRLim, 2, quantile, probs = c(0.90, 0.95, 0.99), na.rm = TRUE)


```

```{r}
# Mostrar resultados
 # Convertimos a data frame largo para kable
  df_VaR <- as.data.frame(VaR_individual)
  df_VaR <- tibble::rownames_to_column(df_VaR, "Nivel_Confianza") %>%
    pivot_longer(-Nivel_Confianza, names_to = "Emisora", values_to = "VaR") %>%
    mutate(Simulaciones = s) %>%
    select(Simulaciones, everything())

  knitr::kable(
    df_VaR,
    caption = paste("VaR Individual por Emisora -", s, "Simulaciones"),
    digits = 4,
    align = "c"
  )

```




**Simulación bootstrap para VaR del portafolio completo**
```{r}
#Portafolio

# Suposiciones: ya tienes Rend calculado como una matriz de rendimientos (n-1 x m)
# y d1 como la matriz de precios originales (n x m)
VaRconvergencia <- list()  # para almacenar los resultados

for (s in numsim) {
  
  VaRLim <- numeric(s)  # almacenar VaR por simulación
  
  for (j in 1:s) {
    
    PL_sim <- numeric(ncol(d1))  # Pérdida simulada por emisora
    for (k in 1:ncol(d1)) {
      y <- Rend[, k]  # rendimientos históricos de emisora k
      r <- sample(y, 1, replace = TRUE)  # rendimiento simulado
      PA <- d1[n, k]  # precio actual
      PL_sim[k] <- PA - (PA * (1 + r))  # pérdida simulada
    }
    
    PL_total <- sum(PL_sim)  # pérdida total del portafolio
    VaRLim[j] <- PL_total
  }
  
  VaRconvergencia[[as.character(s)]] <- quantile(VaRLim, c(0.90, 0.95, 0.99))
}

# Mostrar resultados
for (s in names(VaRconvergencia)) {
  cat("\nVaR para", s, "simulaciones:\n")
  print(VaRconvergencia[[s]])
}

```

## VaR y ES por Alisado Exponencial 

```{r}
# Nivel de alisado exponencial
alpha <- 0.95  # Cambia a 0.94 o 0.96 si lo deseas

# Función para calcular VaR y ES con alisado exponencial
VaR_ES_alisado <- function(pl_vector, niveles_confianza, alpha = 0.95) {
  pl_vector <- na.omit(pl_vector)                    # Elimina valores NA
  n <- length(pl_vector)
  pl_ord <- sort(pl_vector, decreasing = TRUE)       # Ordena pérdidas de mayor a menor
  
  # Calcula pesos exponenciales normalizados
  pesos <- rev(alpha^(0:(n - 1)) * (1 - alpha))
  pesos <- pesos / sum(pesos)
  
  Fx <- cumsum(pesos)                                # Distribución acumulada

  # Inicializa vectores de resultados
  VaR_vec <- numeric(length(niveles_confianza))
  ES_vec <- numeric(length(niveles_confianza))
  
  # Calcula VaR y ES para cada nivel de confianza
  for (i in seq_along(niveles_confianza)) {
    c <- niveles_confianza[i]
    idx <- max(which(Fx <= c)) + 1
    VaR_vec[i] <- pl_ord[idx]
    ES_vec[i] <- sum(pl_ord[1:idx] * pesos[1:idx]) / sum(pesos[1:idx])
  }
  
  return(list(VaR = VaR_vec, ES = ES_vec))
}

# Lista para guardar resultados por emisora
VaR_Exp <- list()

# Itera por columnas (emisoras) en la matriz PL
for (j in seq_len(ncol(PL))) {
  nombre <- colnames(PL)[j]
  resultado <- VaR_ES_alisado(PL[, j], nc, alpha)
  
  # Crea tablas de VaR y ES para diferentes horizontes temporales
  VaR_tabla <- t(sapply(dias, function(d) resultado$VaR * sqrt(d)))
  ES_tabla  <- t(sapply(dias, function(d) resultado$ES * sqrt(d)))
  
  colnames(VaR_tabla) <- paste0("VaR_", nc * 100, "%")
  rownames(VaR_tabla) <- paste0(dias, " días")
  
  colnames(ES_tabla) <- paste0("ES_", nc * 100, "%")
  rownames(ES_tabla) <- paste0(dias, " días")
  
  VaR_Exp[[nombre]] <- list(VaR = VaR_tabla, ES = ES_tabla)
}



```

# Tabla 

```{r}
# 1. Crear tabla resumen en formato largo
tabla_resumen <- do.call(rbind, lapply(names(VaR_Exp), function(nombre) {
  var_tabla <- as.data.frame(VaR_Exp[[nombre]]$VaR)
  es_tabla  <- as.data.frame(VaR_Exp[[nombre]]$ES)

  var_tabla$Horizonte <- rownames(var_tabla)
  es_tabla$Horizonte  <- rownames(es_tabla)

  # Renombrar columnas para que coincidan
  colnames(var_tabla) <- gsub("VaR_", "", colnames(var_tabla))
  colnames(es_tabla)  <- gsub("ES_", "", colnames(es_tabla))

  # Convertir a formato largo
  var_long <- pivot_longer(var_tabla, cols = -Horizonte, names_to = "Confianza", values_to = "VaR")
  es_long  <- pivot_longer(es_tabla,  cols = -Horizonte, names_to = "Confianza", values_to = "ES")

  # Unir y agregar nombre de emisora
  resumen <- left_join(var_long, es_long, by = c("Horizonte", "Confianza"))
  resumen$Emisora <- nombre

  return(resumen)
}))

# 2. Reordenar columnas
tabla_resumen <- tabla_resumen %>%
  select(Emisora, Horizonte, Confianza, VaR, ES) %>%
  arrange(Emisora, Horizonte, Confianza)

# 3. Convertir de formato largo a ancho
tabla_tmp <- tabla_resumen %>%
  pivot_wider(
    names_from = Confianza,
    values_from = c(VaR, ES),
    names_sep = "_"
  )

# 4. Limpiar nombres de columnas y seleccionar en el orden deseado
tabla_final <- tabla_tmp %>%
  rename_with(~ gsub("%", "", .x)) %>%
  select(Emisora, Horizonte, VaR_95, VaR_97, VaR_99, ES_95, ES_97, ES_99)

tabla_final <- tabla_final %>%
  mutate(Emisora = factor(Emisora, levels = paste0("P", sort(as.numeric(str_extract(unique(Emisora), "\\d+")))))) %>%
  arrange(Emisora, Horizonte)


# 5. Mostrar tabla final
tabla_final
```










# Valor en Riesgo paramétrico


```{r}
# --- Cálculo de volatilidades ---
volatilidad <- apply(Rend, 2, sd)  # Desviación estándar por emisora

# --- Funciones de VaR y ES paramétrico ---
fVaR <- function(nc, sigma, t) qnorm(nc) * sigma * sqrt(t)
fES <- function(nc, sigma, t) dnorm(qnorm(nc)) / (1 - nc) * sigma * sqrt(t)

# --- Inicializar tabla de resultados ---
resultados <- dplyr::bind_rows()

# --- Loop por emisora, horizonte y nivel de confianza ---
for (j in 1:m) {
  sigma <- volatilidad[j]
  emisora <- colnames(Rend)[j]  # Asegúrate que colnames() sea del mismo objeto que usaste para volatilidad
  
  for (h in dias) {
    fila <- data.frame(Emisora = emisora, Horizonte = h)
    
    for (i in seq_along(nc)) {
      nivel <- nc[i]
      var <- fVaR(nivel, sigma, h)   # En rendimiento
      es  <- fES(nivel, sigma, h)   # En rendimiento
      
      # Agrega columnas dinámicamente
      fila[[paste0("VaR", substr(nivel, 3, 4))]] <- var
      fila[[paste0("ES", substr(nivel, 3, 4))]]  <- es
    }
    
    resultados <- dplyr::bind_rows(resultados, fila)
  }
}

```


### Tabla 

```{r}

# --- VaR y ES para el portafolio ---
for (h in dias) {
  fila <- data.frame(Emisora = "PT", Horizonte = h)
  for (i in seq_along(nc)) {
    nivel <- nc[i]
    var <- fVaR(nivel, volatilidad.port, h) * sum(valor_invertido)
    es  <- fES(nivel, volatilidad.port, h) * sum(valor_invertido)
    fila[[paste0("VaR", substr(nivel, 3, 4))]] <- var
    fila[[paste0("ES", substr(nivel, 3, 4))]]  <- es
  }
  resultados <- rbind(resultados, fila)
}

# Mostrar tabla final
print(resultados)
```




#Delta Normal

```{r}

```





### fisher 
```{r}
VaR_ES_CornishFisher <- function(pl_vector, niveles_confianza) {
  pl_vector <- na.omitt(pl_vector)
  mu <- mean(pl_vector)
  sigma <- sd(pl_vector)
  S <- mean((pl_vector - mu)^3) / sigma^3  # Asimetría
  K <- mean((pl_vector - mu)^4) / sigma^4  # Curtosis
  
  z <- qnorm(niveles_confianza)
  
  # Ajuste Cornish-Fisher
  z_cf <- z + (1/6)*(z^2 - 1)*S + (1/24)*(z^3 - 3*z)*(K - 3) - (1/36)*(2*z^3 - 5*z)*S^2
  
  VaR <- -(mu + z_cf * sigma)
  
  # ES paramétrico aproximado (normal ajustado con z_cf)
  ES <- -(mu + sigma * dnorm(z_cf) / (1 - niveles_confianza))
  
  return(list(VaR = VaR, ES = ES))
}

```

```{r}
VaR_CF <- list()

for (j in seq_len(ncol(PL))) {
  nombre <- colnames(PL)[j]
  resultado <- VaR_ES_CornishFisher(PL[, j], nc)
  
  # Expandir con la raíz del tiempo para cada horizonte
  VaR_tabla <- t(sapply(dias, function(d) resultado$VaR * sqrt(d)))
  ES_tabla  <- t(sapply(dias, function(d) resultado$ES * sqrt(d)))
  
  colnames(VaR_tabla) <- paste0("VaR_", nc * 100, "%")
  colnames(ES_tabla)  <- paste0("ES_", nc * 100, "%")
  
  rownames(VaR_tabla) <- paste0(dias, " días")
  rownames(ES_tabla)  <- paste0(dias, " días")
  
  VaR_CF[[nombre]] <- list(VaR = VaR_tabla, ES = ES_tabla)
}

```








```{r}

tabla_resumen_CF <- do.call(rbind, lapply(names(VaR_CF), function(nombre) {
  var_tabla <- as.data.frame(VaR_CF[[nombre]]$VaR)
  es_tabla  <- as.data.frame(VaR_CF[[nombre]]$ES)
  
  var_tabla$Horizonte <- rownames(var_tabla)
  es_tabla$Horizonte  <- rownames(es_tabla)
  
  colnames(var_tabla) <- gsub("VaR_", "", colnames(var_tabla))
  colnames(es_tabla)  <- gsub("ES_", "", colnames(es_tabla))
  
  var_long <- pivot_longer(var_tabla, cols = -Horizonte, names_to = "Confianza", values_to = "VaR")
  es_long  <- pivot_longer(es_tabla,  cols = -Horizonte, names_to = "Confianza", values_to = "ES")
  
  resumen <- left_join(var_long, es_long, by = c("Horizonte", "Confianza"))
  resumen$Emisora <- nombre
  return(resumen)
}))

# Ordenar correctamente los horizontes
tabla_resumen_CF$Horizonte <- factor(tabla_resumen_CF$Horizonte, 
                                     levels = paste0(dias, " días"), 
                                     ordered = TRUE)

tabla_resumen_CF <- tabla_resumen_CF %>%
  select(Emisora, Horizonte, Confianza, VaR, ES) %>%
  arrange(Emisora, Horizonte, Confianza)

# Vista final
tabla_resumen_CF 
```























































