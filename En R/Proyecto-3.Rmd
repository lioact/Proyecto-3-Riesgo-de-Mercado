---
title: "Proyecto 3 Riesgo de Mercado"
author: Hernández Fernández Maria Fernanda,Rosas Rios Leonardo Daniel,José Domingo
  Cortes Sandria, Pastrana Basilio Martha Lizeth
date: "2025-04-27"
output:
  pdf_document:
    toc: true
  html_document:
    toc: true
    number_sections: true
---

# Selección de Activos


# Valor en Riesgo no paramétrico

```{r, message=FALSE, warning=FALSE}
library(quantmod) # para descargar datos de Yahoo Finance
library(goftest) # para pruebas de bondad de ajuste
library(corrplot) # para graficar matrices de correlación
library(fitdistrplus) # para ajustar distribuciones
library(dplyr) # para manipulación de datos
library(VGAM) # para ajustar distribuciones
library(tidyr) # para manipulación de datos
library(ggplot2) # para graficar
library(lubridate) # para manipulación de fechas
library(dplyr)
library(tidyr)
library(knitr)
library(stringr)

```

**Emisoras**
```{r}
cartera <- c("AAPL","MSFT","NVDA","AMZN","META","GOOGL","AVGO","GOOG","TSLA","WMT","INTC","JPM","F","NKE","GS","NFLX","CVX","ADBE","BAC","C") 

getSymbols(cartera,src = "yahoo",from="2022-01-01", to="2025-03-01")
```
**Datos**

```{r}
d1 <- data.frame(P1=AAPL$AAPL.Close,P2=MSFT$MSFT.Close,P3=NVDA$NVDA.Close,P4=AMZN$AMZN.Close,P5=META$META.Close,P6=GOOGL$GOOGL.Close,P7=AVGO$AVGO.Close,P8=GOOG$GOOG.Close,P9=TSLA$TSLA.Close,P10=WMT$WMT.Close,P11=INTC$INTC.Close,P12=JPM$JPM.Close,P13=F$F.Close,P14=NKE$NKE.Close,P15=GS$GS.Close,P16=NFLX$NFLX.Close,P17=CVX$CVX.Close,P18=ADBE$ADBE.Close,P19=BAC$BAC.Close,P20=C$C.Close)


```

```{r, message=FALSE, warning=FALSE}

d1$Fecha <- index(AAPL)  

# Convertir d1 a formato data.frame si no lo es (en caso de provenir de un objeto xts):
d1_df <- data.frame(Fecha = d1$Fecha, coredata(d1)[ , !(names(d1) %in% "Fecha")])

# Convertir a formato largo: una fila por cada fecha y ticker
d1_larga <- pivot_longer(d1_df, 
                         cols = -Fecha, 
                         names_to = "Ticker", 
                         values_to = "Close")

# Graficar la serie de tiempo de precios de cierre
ggplot(d1_larga, aes(x = Fecha, y = Close, color = Ticker)) +
  geom_line(size = 0.8) +
  labs(title = "Serie de Tiempo de Precios de Cierre",
       x = "Fecha", 
       y = "Precio de Cierre (USD)") +
  theme_minimal() +
  theme(legend.position = "bottom")
```

```{r}

colnames(d1) <- c("P1","P2","P3","P4","P5","P6","P7","P8","P9","P10","P11","P12","P13","P14","P15","P16","P17","P18","P19","P20")

n <- length(d1$P1) #número de días 
m <- length(d1[1,])  #número de emisoras
nc <- c(0.95,0.97,0.99) #niveles de confianza
numsim <- c(5000,10000,20000) #número de simulaciones
dias <- c(1, 7, 15, 30, 60, 90, 180)  #horizontes de tiempo

```


```{r}
# Separar solo las columnas de precios (sin la columna Fecha)
d1_precios <- d1[ , 1:20]  # si las primeras 20 columnas son los precios

n <- nrow(d1_precios)
m <- ncol(d1_precios)

Rend <- matrix(NA, nrow = n - 1, ncol = m)
colnames(Rend) <- paste0("P", 1:m)

for(k in 1:m){
  for(j in 1:(n-1)){
    Rend[j, k] <- d1_precios[j+1, k] / d1_precios[j, k] - 1
  }
}

```




**Grafica de los rendimientos**

```{r}
# Crear un data frame con las fechas adecuadas
fechas <- index(AAPL)[-1]  # remover la primera para alinear con los rendimientos
Rend_df <- as.data.frame(Rend)
Rend_df$Fecha <- fechas

# Convertir a formato largo
Rend_long <- pivot_longer(Rend_df, cols = starts_with("P"),
                          names_to = "Emisora", values_to = "Rendimiento")


```


**Función de perdidas y ganancias**
```{r}
PL <- matrix(data=0,nrow = n-1,ncol = m+1)
colnames(PL) <- c(paste0("P", 1:m), "PT")

for(k in 1:m){
  for(j in 1:n-1){
    PL[j,k] <- d1[n,k]-d1[n,k]*(1+Rend[j,k])  #pérdida/ganancia simulada
    PL[j,(m+1)] <- sum(PL[j,1:m])           #portafolio total
  }
}

```

# VaR por Simulación Histórica 

**VaR individual**

```{r}
VaRInd <- matrix(nrow = m, ncol = length(nc))
colnames(VaRInd) <- c("VaR_95%","VaR_97%","VaR_99%")
rownames(VaRInd) <- colnames(PL)[1:m]

for(k in 1:m){
  for(j in seq_along(nc)){
    VaRInd[k, j] <- quantile(PL[,k], nc[j], na.rm = TRUE)[1]
  }
}

#VaR ajustado a diferentes horizontes de tiempo

VaRIndD <- list()  #lista de emisoras

for (k in 1:m) {
  MVaRD <- matrix(nrow = length(dias), ncol = length(nc))
  for (i in seq_along(dias)) {
    for (j in seq_along(nc)) {
      MVaRD[i, j] <- VaRInd[k, j] * sqrt(dias[i])
    }
  }
  colnames(MVaRD) <- paste0("VaR_", nc * 100, "%")
  rownames(MVaRD) <- paste0(dias, "días")
  VaRIndD[[ colnames(PL)[k] ]] <- MVaRD
}
# ES: Expected Shortfall
VaR_ES <- function(PL, niveles_confianza = c(0.95, 0.97, 0.99)) {
  m <- ncol(PL)  # número de emisoras
  VaR <- matrix(NA, nrow = m, ncol = length(niveles_confianza))
  ES  <- matrix(NA, nrow = m, ncol = length(niveles_confianza))
  
  colnames(VaR) <- paste0("VaR_", niveles_confianza * 100, "%")
  colnames(ES)  <- paste0("ES_", niveles_confianza * 100, "%")
  rownames(VaR) <- rownames(ES) <- colnames(PL)
  
  for (k in 1:m) {
    for (j in seq_along(niveles_confianza)) {
      var_kj <- quantile(PL[, k], niveles_confianza[j], na.rm = TRUE)
      VaR[k, j] <- var_kj
      ES[k, j] <- mean(PL[, k][PL[, k] > var_kj], na.rm = TRUE)
    }
  }
  
  return(list(VaR = VaR, ES = ES))
}

ES.SH <- VaR_ES(PL) # Calcular VaR y ES


```
#### Creacion de tabla 

```{r, message=FALSE, warning=FALSE}
#Creacion de tabla 

# Combinar todas las tablas en una sola con columna de emisora y horizonte
tabla_individual <- do.call(rbind, lapply(names(VaRIndD), function(nombre) {
  df <- as.data.frame(VaRIndD[[nombre]])
  df$Horizonte <- rownames(df)
  df$Emisora <- nombre
  df$ES_95 <- ES.SH$ES[nombre, 1]
  df$ES_97 <- ES.SH$ES[nombre, 2]
  df$ES_99 <- ES.SH$ES[nombre, 3]
  df
}))

# Reordenar columnas para claridad
tabla_individual <- tabla_individual[, c("Emisora", "Horizonte", 
                                         "VaR_95%", "VaR_97%", "VaR_99%", 
                                         "ES_95", "ES_97", "ES_99")]

## Ordenar por el número que sigue a la 'P'
tabla_individual <- tabla_individual[order(as.numeric(gsub("P", "", tabla_individual$Emisora)),
                                           as.numeric(tabla_individual$Horizonte)), ]


# Mostrar como tabla en RMarkdown
tabla_individual

```


## VaR individual por Simulación Monte Carlo Normal 
```{r, warning=FALSE}

y <- function(x) {
  mod <- fitdist(x[!is.na(x)], "norm", method = "mle")
  return(mod$estimate)
}

p <- apply(Rend, 2, y)
muv <- p[1, ]
sigmav <- p[2, ]

```



```{r, warning=FALSE}
y(Rend[,1])
```



```{r}
set.seed(350)
RendSM <- matrix(NA, nrow = n, ncol = m)
RevalSM <- matrix(NA, nrow = n, ncol = m)
PLSM <- matrix(NA, nrow = n, ncol = m)
colnames(RendSM) <- colnames(RevalSM) <- colnames(PLSM) <- colnames(RendSM)

#Simulaciones
for (j in 1:m) {  #por emisora
  mu <- muv[j]
  sigma <- sigmav[j]
  PA <- d1[n, j]  #precio actual

  for (k in 1:n) {  # por día
    RendSM[k, j] <- rnorm(1, mu, sigma)
    RevalSM[k, j] <- PA * (1 + RendSM[k, j])
    PLSM[k, j] <- PA - RevalSM[k, j]
  }
}

```

```{r}
# Creacion de tabla para visualizacion 
# Calcular resumen estadístico
resumen_mat <- apply(PLSM, 2, summary)  # columnas = emisoras
resumen_df <- as.data.frame(t(resumen_mat))

resumen_df$Emisora <- c("P1", "P2", "P3", "P4", "P5","P6", "P7", "P8", "P9", "P10","P11", "P12", "P13", "P14", "P15","P16", "P17", "P18", "P19","P20")

resumen_df <- resumen_df[, c("Emisora", setdiff(names(resumen_df), "Emisora"))]


```


```{r}

# Mostrar con kable
knitr::kable(resumen_df,
             caption = "Resumen estadístico de las pérdidas simuladas (PLSM)",
             digits = 4)

```

```{r}
VaRSMd <- list()  #VaR diarios escalados

for (j in 1:m) {
  ne <- colnames(PL)[j]
  
  VaRd <- quantile(PL[, j], probs = nc, na.rm = TRUE)  #VaR diario
  
  VaRe <- matrix(NA, nrow = length(dias), ncol = length(nc)) #escalado a ht
  colnames(VaRe) <- paste0("VaR_", nc * 100, "%")
  rownames(VaRe) <- paste0(dias, " días")
  
  for (i in 1:length(dias)) {
    VaRe[i, ] <- as.numeric(VaRd) * sqrt(dias[i])
  }
  VaRSMd[[ne]] <- VaRe
}

```

```{r}
knitr::kable(VaRSMd[["P1"]], digits = 4)

```

```{r, warning=FALSE}
VaRconv <- list()  #resultados por emisora

for (p in 1:m) {
  ysm <- na.omit(Rend[, p])
  nombre <- colnames(Rend)[p]
  
  mod <- fitdist(ysm, "norm", method = "mle")  #Estimar parámetros normales
  mu <- mod$estimate[1]
  sigma <- mod$estimate[2]
  
  pf <- d1[nrow(d1), p]  #último precio
  
  VaRnumsim <- list()   #distintos tamaños de simulación
  
  for (nsim in numsim) {
    VaRm <- matrix(NA, nrow = nsim, ncol = length(nc))
    colnames(VaRm) <- paste0("VaR_", nc * 100, "%")
    
    plhist <- numeric(0)  # vector acumulativo de pérdidas simuladas
    
    for (j in 1:nsim) {
      rendsim <- rnorm(1, mu, sigma)
      reval <- pf * (1 + rendsim)
      pl <- pf - reval
      
      plhist <- c(plhist, pl)
      
      for (i in seq_along(nc)) {
        VaRm[j, i] <- quantile(plhist, nc[i], na.rm = TRUE)
      }
    }
    
    VaRnumsim[[as.character(nsim)]] <- VaRm
  }
  
  VaRconv[[nombre]] <- VaRnumsim
}

```



```{r}
resVaR <- data.frame() #promedios finales

for (emisora in names(VaRconv)) {
  for (nsim in names(VaRconv[[emisora]])) {
    matrizVaR <- VaRconv[[emisora]][[nsim]]
    
    promedios <- colMeans(matrizVaR, na.rm = TRUE)
    
    temp <- data.frame(
      Emisora = emisora,
      Simulaciones = as.integer(nsim),
      Nivel_Confianza = names(promedios),
      VaR_Promedio = as.numeric(promedios)
    )
    
    resVaR <- bind_rows(resVaR, temp)
  }
}

```



```{r}

knitr::kable(resVaR, caption = "VaR promedio por emisora y número de simulaciones (Simulación Monte Carlo Normal)", digits = 4,align = "c")

```

**Expected Shortfall SM-Normal**
```{r}

rownames(ES.MC$ES) <- colnames(PLSM)  # Asegurarse de que coincidan con los nombres de las emisoras

# Convertir la matriz a un data.frame
ES_df <- as.data.frame(ES.MC$ES)

# Agregar columna "Emisora" explícitamente
ES_df$Emisora <- rownames(ES_df)

# Reordenar columnas para que "Emisora" esté primero
ES_df <- ES_df[, c("Emisora", setdiff(names(ES_df), "Emisora"))]

# Imprimir la tabla con knitr::kable
knitr::kable(ES_df, caption = "Expected Shortfall (ES) por Simulación Monte Carlo Normal",digits = 4)

```

## VaR individual por Simulación Monte Carlo Laplace
```{r, warning=FALSE, message=FALSE}

#Ajustamos distribución Laplace a los rendimientos

# Función para estimar parámetros Laplace
ajustar_laplace <- function(x) {
  datos <- x[!is.na(x)]
  mod <- vglm(datos ~ 1, laplace, trace = FALSE)
  coef <- Coef(mod)
  return(coef)
}

# Estimar parámetros Laplace para cada emisora
param_laplace <- apply(Rend, 2, ajustar_laplace)
mu_lap <- param_laplace[1, ]
b_lap <- param_laplace[2, ]
```

```{r}
#Pérdidas
set.seed(123)

VaR_Laplace_conv <- list()

for (p in 1:m) {
  mu <- mu_lap[p]
  b <- b_lap[p]
  pf <- d1[n, p]  # último precio
  
  VaR_sims <- list()
  
  for (nsim in numsim) {
    pl_hist <- numeric(nsim)
    VaRm <- matrix(NA, nrow = nsim, ncol = length(nc))
    colnames(VaRm) <- paste0("VaR_", nc * 100, "%")
    
    for (j in 1:nsim) {
      rend_sim <- rlaplace(1, location = mu, scale = b)
      reval <- pf * (1 + rend_sim)
      pl <- pf - reval
      pl_hist[j] <- pl
      
      for (i in seq_along(nc)) {
        VaRm[j, i] <- quantile(pl_hist[1:j], probs = nc[i], na.rm = TRUE)
      }
    }
    
    VaR_sims[[as.character(nsim)]] <- VaRm
  }
  
  VaR_Laplace_conv[[colnames(Rend)[p]]] <- VaR_sims
}
```

```{r}
#Calculamos promedios de VaR por emisora y simulación
resVaR_Laplace <- data.frame()

for (emisora in names(VaR_Laplace_conv)) {
  for (nsim in names(VaR_Laplace_conv[[emisora]])) {
    matrizVaR <- VaR_Laplace_conv[[emisora]][[nsim]]
    promedios <- colMeans(matrizVaR, na.rm = TRUE)
    
    temp <- data.frame(
      Emisora = emisora,
      Simulaciones = as.integer(nsim),
      Nivel_Confianza = names(promedios),
      VaR_Promedio = as.numeric(promedios)
    )
    
    resVaR_Laplace <- bind_rows(resVaR_Laplace, temp)
  }
}


knitr::kable(resVaR_Laplace,caption = "Promedio de VaR por Emisora y Nivel de Confianza",digits = 4,align = "c")

```

**Expected Shortfall SM-Laplace**
```{r}
ES.MCL <- VaR_ES(VaRm)
```

```{r}
knitr::kable(
  ES.MCL,
  caption = "Expected Shortfall (ES) por Simulación Monte Carlo Laplace",
  digits = 4,
  align = "c")
```



##Simulación Bootstrapping


**Simulación Bootstrapping multivariada del portafolio**
```{r}

# Simulación bootstrap multivariada
RendSim <- matrix(NA, nrow = n, ncol = m)
Reval <- matrix(NA, nrow = n, ncol = m)
PL <- matrix(NA, nrow = n, ncol = m)
colnames(RendSim) <- colnames(Reval) <- colnames(PL) <- colnames(d1)

# Para cada emisora, simula rendimientos y calcula P&L
for (k in 1:m) {
  y <- Rend[, k]  # rendimientos históricos de la emisora k
  PA <- d1[n, k]  # precio actual

  for (j in 1:n) {
    RendSim[j, k] <- sample(y, 1, replace = TRUE)
    Reval[j, k] <- PA * (1 + RendSim[j, k])
    PL[j, k] <- PA - Reval[j, k]
  }
}

# Pérdida total del portafolio
PL_Total <- rowSums(PL, na.rm = TRUE)

#Calcular VaR por Simulación Bootstrap 
VaR_Bootstrap <- quantile(PL_Total, probs = c(0.90, 0.95, 0.99), na.rm = TRUE)

print(VaR_Bootstrap)

```


**Simulación bootstrap para VaR individual**

```{r}
#Individual
# Suposiciones: ya tienes Rend calculado como una matriz de rendimientos (n-1 x m)
# y d1 como la matriz de precios originales (n x m)
VaRconvergencia <- list()  # para almacenar los resultados

for (s in numsim) {

  VaRLim <- matrix(NA, nrow = s, ncol = m)  # almacenar pérdidas por emisora
  colnames(VaRLim) <- colnames(d1)

  for (j in 1:s) {
    
    PL_sim <- numeric(ncol(d1))  # Pérdida simulada por emisora
    for (k in 1:ncol(d1)) {
      y <- Rend[, k]  # rendimientos históricos de emisora k
      r <- sample(y, 1, replace = TRUE)  # rendimiento simulado
      PA <- d1[n, k]  # precio actual
      PL_sim[k] <- PA - (PA * (1 + r))  # pérdida simulada
    }
    
    VaRLim[j, ] <- PL_sim  # guardar pérdidas individuales

  }
}
  
VaR_individual <- apply(VaRLim, 2, quantile, probs = c(0.90, 0.95, 0.99), na.rm = TRUE)


```

```{r}
# Mostrar resultados
 # Convertimos a data frame largo para kable
  df_VaR <- as.data.frame(VaR_individual)
  df_VaR <- tibble::rownames_to_column(df_VaR, "Nivel_Confianza") %>%
    pivot_longer(-Nivel_Confianza, names_to = "Emisora", values_to = "VaR") %>%
    mutate(Simulaciones = s) %>%
    select(Simulaciones, everything())

  knitr::kable(
    df_VaR,
    caption = paste("VaR Individual por Emisora -", s, "Simulaciones"),
    digits = 4,
    align = "c"
  )

```




**Simulación bootstrap para VaR del portafolio completo**
```{r}
#Portafolio

# Suposiciones: ya tienes Rend calculado como una matriz de rendimientos (n-1 x m)
# y d1 como la matriz de precios originales (n x m)
VaRconvergencia <- list()  # para almacenar los resultados

for (s in numsim) {
  
  VaRLim <- numeric(s)  # almacenar VaR por simulación
  
  for (j in 1:s) {
    
    PL_sim <- numeric(ncol(d1))  # Pérdida simulada por emisora
    for (k in 1:ncol(d1)) {
      y <- Rend[, k]  # rendimientos históricos de emisora k
      r <- sample(y, 1, replace = TRUE)  # rendimiento simulado
      PA <- d1[n, k]  # precio actual
      PL_sim[k] <- PA - (PA * (1 + r))  # pérdida simulada
    }
    
    PL_total <- sum(PL_sim)  # pérdida total del portafolio
    VaRLim[j] <- PL_total
  }
  
  VaRconvergencia[[as.character(s)]] <- quantile(VaRLim, c(0.90, 0.95, 0.99))
}

# Mostrar resultados
for (s in names(VaRconvergencia)) {
  cat("\nVaR para", s, "simulaciones:\n")
  print(VaRconvergencia[[s]])
}

```

## VaR y ES por Alisado Exponencial 

```{r}
# Nivel de alisado exponencial
alpha <- 0.95  # Cambia a 0.94 o 0.96 si lo deseas

# Función para calcular VaR y ES con alisado exponencial
VaR_ES_alisado <- function(pl_vector, niveles_confianza, alpha = 0.95) {
  pl_vector <- na.omit(pl_vector)                    # Elimina valores NA
  n <- length(pl_vector)
  pl_ord <- sort(pl_vector, decreasing = TRUE)       # Ordena pérdidas de mayor a menor
  
  # Calcula pesos exponenciales normalizados
  pesos <- rev(alpha^(0:(n - 1)) * (1 - alpha))
  pesos <- pesos / sum(pesos)
  
  Fx <- cumsum(pesos)                                # Distribución acumulada

  # Inicializa vectores de resultados
  VaR_vec <- numeric(length(niveles_confianza))
  ES_vec <- numeric(length(niveles_confianza))
  
  # Calcula VaR y ES para cada nivel de confianza
  for (i in seq_along(niveles_confianza)) {
    c <- niveles_confianza[i]
    idx <- max(which(Fx <= c)) + 1
    VaR_vec[i] <- pl_ord[idx]
    ES_vec[i] <- sum(pl_ord[1:idx] * pesos[1:idx]) / sum(pesos[1:idx])
  }
  
  return(list(VaR = VaR_vec, ES = ES_vec))
}

# Lista para guardar resultados por emisora
VaR_Exp <- list()

# Itera por columnas (emisoras) en la matriz PL
for (j in seq_len(ncol(PL))) {
  nombre <- colnames(PL)[j]
  resultado <- VaR_ES_alisado(PL[, j], nc, alpha)
  
  # Crea tablas de VaR y ES para diferentes horizontes temporales
  VaR_tabla <- t(sapply(dias, function(d) resultado$VaR * sqrt(d)))
  ES_tabla  <- t(sapply(dias, function(d) resultado$ES * sqrt(d)))
  
  colnames(VaR_tabla) <- paste0("VaR_", nc * 100, "%")
  rownames(VaR_tabla) <- paste0(dias, " días")
  
  colnames(ES_tabla) <- paste0("ES_", nc * 100, "%")
  rownames(ES_tabla) <- paste0(dias, " días")
  
  VaR_Exp[[nombre]] <- list(VaR = VaR_tabla, ES = ES_tabla)
}



```

```{r}
# 1. Crear tabla resumen en formato largo
tabla_resumen <- do.call(rbind, lapply(names(VaR_Exp), function(nombre) {
  var_tabla <- as.data.frame(VaR_Exp[[nombre]]$VaR)
  es_tabla  <- as.data.frame(VaR_Exp[[nombre]]$ES)

  var_tabla$Horizonte <- rownames(var_tabla)
  es_tabla$Horizonte  <- rownames(es_tabla)

  # Renombrar columnas para que coincidan
  colnames(var_tabla) <- gsub("VaR_", "", colnames(var_tabla))
  colnames(es_tabla)  <- gsub("ES_", "", colnames(es_tabla))

  # Convertir a formato largo
  var_long <- pivot_longer(var_tabla, cols = -Horizonte, names_to = "Confianza", values_to = "VaR")
  es_long  <- pivot_longer(es_tabla,  cols = -Horizonte, names_to = "Confianza", values_to = "ES")

  # Unir y agregar nombre de emisora
  resumen <- left_join(var_long, es_long, by = c("Horizonte", "Confianza"))
  resumen$Emisora <- nombre

  return(resumen)
}))

# 2. Reordenar columnas
tabla_resumen <- tabla_resumen %>%
  select(Emisora, Horizonte, Confianza, VaR, ES) %>%
  arrange(Emisora, Horizonte, Confianza)

# 3. Convertir de formato largo a ancho
tabla_tmp <- tabla_resumen %>%
  pivot_wider(
    names_from = Confianza,
    values_from = c(VaR, ES),
    names_sep = "_"
  )

# 4. Limpiar nombres de columnas y seleccionar en el orden deseado
tabla_final <- tabla_tmp %>%
  rename_with(~ gsub("%", "", .x)) %>%
  select(Emisora, Horizonte, VaR_95, VaR_97, VaR_99, ES_95, ES_97, ES_99)

tabla_final <- tabla_final %>%
  mutate(Emisora = factor(Emisora, levels = paste0("P", sort(as.numeric(str_extract(unique(Emisora), "\\d+")))))) %>%
  arrange(Emisora, Horizonte)


# 5. Mostrar tabla final
tabla_final
```





















